{-# LANGUAGE DataKinds #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}

module UserRow where

import Contravariant.Extras (contrazip3)
import Data.Functor.Contravariant ((>$<))
import Data.Int (Int64)
import Data.Text (Text)
import Hasql.Connection (Connection)
import qualified Hasql.Decoders as D
import qualified Hasql.Encoders as E

import Hasql.Session (QueryError, run, statement)
import Hasql.Statement (Statement (..))

createUsersTable :: Connection -> IO (Either QueryError ())
createUsersTable =
    run $
        statement () $
            Statement
                "CREATE TEMP TABLE users (id INT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, email VARCHAR(20) NOT NULL CHECK (TRIM(email) <> ''), is_active BOOLEAN NOT NULL)"
                E.noParams
                D.noResult
                True

doInsertUsers :: Connection -> IO (Either QueryError Int64)
doInsertUsers =
    run $ do
        insert1 <- statement (User{userId = 1, userEmail = "john@example", userIsActive = True}) insertUser3
        insert2 <- statement (User{userId = 2, userEmail = "jane@example", userIsActive = False}) insertUser3
        pure (insert1 + insert2)

insertUser :: Statement (Text, Maybe Text, Bool) Int64
insertUser = Statement qry rawParams D.rowsAffected True
  where
    rawParams :: E.Params (Text, Maybe Text, Bool)
    rawParams =
        mconcat
            [ (\(x, _, _) -> x) >$< E.param (E.nonNullable E.text)
            , (\(_, x, _) -> x) >$< E.param (E.nullable E.text)
            , (\(_, _, x) -> x) >$< E.param (E.nonNullable E.bool)
            ]

    qry = "INSERT INTO users (id, email, is_active) VALUES ($1, $2, $3)"

data UserRow = User
    { userId :: Int64
    , userEmail :: Text
    , userIsActive :: Bool
    }
    deriving (Show)

userEncoder1 :: E.Params (Text, Maybe Text, Bool)
userEncoder1 =
    contrazip3
        (E.param (E.nonNullable E.text))
        (E.param (E.nullable E.text))
        (E.param (E.nonNullable E.bool))

{- FOURMOLU_DISABLE -}
userEncoder2 :: E.Params UserRow
userEncoder2 =
    mconcat
        [ userId       >$< E.param (E.nonNullable E.int8)
        , userEmail    >$< E.param (E.nonNullable E.text)
        , userIsActive >$< E.param (E.nonNullable E.bool)
        ]
{- FOURMOLU_ENABLE -}

insertUser3 :: Statement UserRow Int64
insertUser3 = Statement qry userEncoder2 D.rowsAffected True
  where
    qry = "INSERT INTO users (id, email, is_active) VALUES ($1, $2, $3)"

userDecoder :: D.Row UserRow
userDecoder =
    User
        <$> D.column (D.nonNullable D.int8)
        <*> D.column (D.nonNullable D.text)
        <*> D.column (D.nonNullable D.bool)

{- FOURMOLU_DISABLE -}
userDecoder2 :: D.Row UserRow
userDecoder2 = do
    userId       <- D.column (D.nonNullable D.int8)
    userEmail    <- D.column (D.nonNullable D.text)
    userIsActive <- D.column (D.nonNullable D.bool)
    pure $
        User
            { userId
            , userEmail
            , userIsActive
            }
{- FOURMOLU_ENABLE -}

listUsers :: Connection -> IO (Either QueryError [UserRow])
listUsers =
    run $
        statement () $
            Statement
                "SELECT id, email, is_active FROM users"
                E.noParams
                (D.rowList userDecoder2)
                True
